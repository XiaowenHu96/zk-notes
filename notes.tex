\documentclass[10pt]{article}

\usepackage[urlcolor=blue, colorlinks=true]{hyperref}
\usepackage{forest}
\usepackage{tikz}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{remark*}{Remark}
\newtheorem{remark}{Remark}
\newtheorem{sublemma}{Lemma}[lemma]
\newcommand{\FFamily}{\mathbb{F}^{(\leq d)}_p[X]}
\newcommand{\FField}{\mathbb{F}_p}
\newcommand{\MyOmega}{e^{2\pi ik/n}}
\newcommand{\HL}[1]{\textcolor{red}{#1}}

\begin{document}
\section*{ZK notes}
\begin{description}
    \item Some keynotes made while learning about ZK, SNARK, STARK and ZK-VM.
    \item Lectures: \href{https://www.youtube.com/playlist?
        list=PLj80z0cJm8QErn3akRcqvxUsyXWC81OGq}{Youtube Playlist}
\end{description}

\section{SNARK}
SNARK is not necessary ZK and can be quite different from STARK and ZK-VM. But
it should be a good starting ground to understand some basic concept.

\subsection{Polynomial Commitment Scheme (PCS)}
A PCS is a functional commitment for the family $\mathcal{F} \in \FFamily$.
A prover commits to univariate polynomial $f$ in $\FFamily$ and can later prove
to the verifier that $v = f(u)$ for public $u, v \in \FField$.

Some examples PCS (here we focus on KZG'10):
\begin{enumerate}
    \item Bulletproof (elliptic curves, but verification is $O(d)$)
    \item KZG'10 (trusted setup, bilinear), Dory'20 (bilinear)
    \item Dark'20 (groups of unknown order)
    \item Hash (FRI)
\end{enumerate}

\subsection{KZG'10}
Set cyclic group $\mathbb{G} = \{0, G, 2 \cdot G, 3 \cdot G, \ldots, (p-1) \cdot
G\}$ of order $p$.

\subsubsection*{Setup algorithm}
\begin{enumerate}
    \item Sample random $\alpha \in \FField$.
    \item $pp = (H_0 = G, H_1 = \alpha \cdot G, \ldots, H_d = \alpha^d \cdot G)
        \in \mathbb{G}^{d+1}$.
    \item \textbf{delete $\alpha$} (i.e., A trusted setup)
\end{enumerate}

\subsubsection*{Commitment}
In short: $commit(pp, f) \rightarrow com_{f}$, where $com_{f} = f(\alpha) \cdot G \in
\mathbb{G}$.\footnote{This is not a hiding commitment} \\

\begin{remark*}
    As a result, the committed message is extremely short (an
    element $G$) regardless how large our polynomial is.
\end{remark*}

But $\alpha$ is deleted during trusted setup, how does prover compute
$f(\alpha)$?\\
Observe:
\begin{description}
    \item $\Rightarrow f(X) = f_0 + f_1X + \ldots + f_dX^d $
    \item $\Rightarrow f(\alpha) \cdot G = f_0 \cdot G + f_1 \cdot \alpha \cdot G 
        + \ldots + f_d \cdot \alpha^d \cdot G $
    \item $\Rightarrow f(\alpha) \cdot G = f_0 \cdot H_0 + f_1 \cdot H_1 + \ldots + f_d
        \cdot H_d $
\end{description}

\subsubsection*{Evaluation}
How to prove $f(u) = v$?\\ 

First Observe:
\begin{enumerate}
\item If $f(u) = v \Longleftrightarrow u$ is a root of polynomial
    $\hat{f}(X) = f(X) - v$.
\item If $u$ is a root of $\hat{f}(X) \Longleftrightarrow \hat{f}(X)$  is divisible
    by $(x - u)$.
\item $f(u) = v \Longleftrightarrow \exists q \in \FFamily$ s.t. $q(X)(X-u)=f(X)-v$
    
\end{enumerate}

\begin{description}
    \item The prover then computes quotient polynomial $q(X) = (f(X) - v) / (X - u)$
        and sends $com_q$ to verifier.
    \item The verifier accepts if $(\alpha - u) \cdot com_q = com_f - v \cdot G$.
\end{description}

LHS:
\begin{description}
    \item $\Rightarrow (\alpha - u) \cdot com_q$
    \item $\Rightarrow (\alpha - u) \cdot (q_0 H_0 + q_1 H_1 + \ldots + q_d H_d)$
    \item $\Rightarrow (\alpha - u) \cdot (q_0 G + q_1 \alpha G + \ldots + q_d \alpha^d G)$
    \item $\Rightarrow commit(pp, (X-u)q(X))$
\end{description}
RHS is similar. \footnote{Important: verifier does not actually need to know
about $\alpha$. The \emph{pairing} is used here to allow verifier to compute
$(\alpha - u) * com_q$ with only $G$ and $H_1$}
\begin{remark*}
    The verification work only take constant time, regardless of the degree of
    the polynomial.
\end{remark*}

\subsubsection*{Extension}
\begin{enumerate}
    \item KZG for k-variant polynomial (PST'13)
    \item Batch proofs: prove a batch of commitments in a single step.
\end{enumerate}


\subsection{A Useful Observation}
A Useful and important observation.

For $0 \neq f \in \FFamily$.
Let $r$ be a random point $r \leftarrow \FField$, the probability 
$pr[f(r) = 0] = d/p$.\footnote{Given $f$ has at most $d$ roots and $p$ elements}

For large enough $p$ and reasonable $d$, e.g., $p \approx 2^{256}$ and $d \leq
2^{40}$, $d/p$ is negligible.

\begin{lemma}\label{observation1}
    for $r \leftarrow \FField$, if $f(r) = 0$, we can conclude $f$ is
    identically zero w.h.p.\footnote{Also holds for multivariate polynomial,
    see SZDL lemma.}
\end{lemma}

Further more, with the same settings. \\
\begin{lemma}\label{observation2}
Let $f, g \in \FFamily$. For $r \leftarrow \FField$, if
$f(r) = g(r)$ then $f = g$.
\end{lemma}
\begin{description}
    \item $\Rightarrow f(r) - g(r) = 0$
    \item $\Rightarrow$ Let $h = f - g$, from Lemma~\ref{observation1}, $h$ is
        identical zero w.h.p.
    \item $\Rightarrow f = g$, w.h.p
\end{description}

\subsection{Zero Test On H}
One of the (and the simplest) poly-IOP tasks that the verifier would like the
prover to do.

\begin{description}
\item Let $\omega \in \FField$ be a primitive $k$-th root of unity (such
    that $\omega^{k} = 1$ and  $\omega^n \neq 1$ for $n < k$).
\item Set $H = \{1, \omega, \omega^2, \ldots, \omega^{k-1}\} \in
    \FField$. 
\item Let polynomial $f \in \FFamily$.
\end{description}

A zero test is a test from verifier to prover to prove that: \textbf{$f$ is
identically zero on set $H$.}

\begin{lemma}\label{zero-test}
    $f$ is zero on $H$ iff $f(X)$ is divisible by $X^k - 1$.
\end{lemma}
\begin{enumerate}
    \item The prover can compute the quotient polynomial $q(X) = f(X) /
        (X^k - 1)$. and send the commitment of $q$ to the verifier.
    \item The verifier then choose random $r \in \FField$ and ask prover
        to open $f(X)$ and $q(X)$ at r.
    \item The verifier then accepts the test if $f(r) = q(r) \cdot (r^k - 1)$
\end{enumerate}
As mentioned in Lemma~\ref{observation2}, two polynomials that agree on a random point $r$
has a high probability that the two polynomials are identical. 
Therefore, the above implies $f(X) = q(X)(X^k - 1)$. This proves $f(X)$ is
indeed divisible by $X^k - 1$, hence from Lemma~\ref{zero-test}, $f$ is
identical on $H$.

\subsection{Interpolate Polynomial}
Plonk.

\subsubsection{Compile a circuit into a computation trace}
\begin{minipage}{.5\textwidth}
\begin{forest}
[$(x_1 + x_2)(x_2 + w_1)$
    [Gate2: $\times$, edge={<-}, edge label={node[midway,left]{77}}
    [Gate0: $+$, edge={<-}, edge label={node[midway,left]{11}}
        [$x_1$, edge={<-}, edge label={node[midway,left]{5}}]
        [$x_2$, edge={<-}, name=n1, edge label={node[midway,right]{6}}]
    ]
    [Gate1: $+$, edge={<-},name=n2, edge label={node[midway,right]{7}}
        [$w_1$, edge={<-}, edge label={node[midway,right]{1}}]
    ]
    ]
]
\draw[->] (n1) -- node[midway,right]{6} (n2);
\end{forest}
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{tabular}{l|r|r|r}
    inputs: & 5 & 6 & 1 \\
    \hline
    & left & right & out \\
    \hline
    Gate0 & 5 & 6 & 11 \\
    Gate1 & 6 & 1 & 7 \\
    Gate2 & 11 & 7 & 77 \\
    \hline
\end{tabular}
\end{minipage}\\
\subsubsection{Encoding the trace as polynomial}
\begin{description}
    \item $C \leftarrow$: total \# of gates
    \item $I \leftarrow |I_x| + |I_w|$: \# inputs to circuit
    \item $d \leftarrow 3|C| + |I| = 12$ for our example. ($3$ since each gate has $3$ inputs).
    \item $H \leftarrow \{1, \omega, \ldots, \omega^{(d-1)}\}$ 
\end{description}

The goal here is to interpolate a polynomial $P$ that encodes the computation
trace. To achieve that, we want to
\begin{enumerate}
    \item let $P$ encodes all inputs, such that $P(\omega^{-j}) =$ inputs \# j
        for all $j = 1, \ldots, |I|$.
    \item let $P$ encodes all wires, such that $\forall l = 0, \ldots, |C|-1$:
        \begin{enumerate}
            \item $P(\omega^{3l}) = $ left input of gate \# $l$.
            \item $P(\omega^{3l+1}) = $ right input of gate \# $l$.
            \item $P(\omega^{3l+2}) = $ output of gate \# $l$.
        \end{enumerate}
\end{enumerate}
This results in $12$ constraints for $P$, which means there exists a $P$ with
degree at most $11$ that satisfies all the constraints. \HL{Prover can then 
constructs $P$ using Fast Fourier Transform in time $O(d\log d)$, which
I don't know how yet.}

\subsubsection{Prove that encoding is correct}
There are four things to prove.\\

\textbf{Inputs are correctly encoded.}\\
Both prover and verifier takes input $x$ and interpolate a polynomial $v(X) \in
\FFamily$ that satisfies $\forall j = 1, \ldots, |I_x|: v(\omega^{-j}) = $input \#j.

\HL{From the slides, it says construction takes time linear to the size of $x$, shouldn't
it still be using FFT and the time is actually $O(n \log n)$?}. 

Then prover just proves that $P(y) - v(y) = 0\ \ \forall y \in H_{inp}$ where
$H_{inp}$ is all the input points, i.e., $\{\omega^{-1}, \ldots,
\omega^{-|I_x|}\}$. This can be done using zero-test.

\textbf{Gates evaluations are correctly encoded.}\\
Interpolate selector polynomial $S(X) \in \FFamily$ such that $\forall l =
0,\ldots, |C| - 1$:
\begin{enumerate}
    \item $S(\omega^{3l}) = 1$ if gate $l$ is addition
    \item $S(\omega^{3l}) = 0$ if gate $l$ is multiplication
\end{enumerate}
Observe $\forall y \in H_{gates} = \{1, \omega^{3}, \omega^{6}, \ldots,
\omega^{3(|C|-1)}\}$:
$$
S(y) \cdot [P(y) + P(\omega y)] + (1 - S(y))\cdot P(y)\cdot P(\omega y) =
P(\omega^{2}y)
$$
When $S(y) = 1$, which means a gate is addition gate, and $[P(y) + P(\omega y)]$
encodes the two inputs of that gate, which equals to $P(\omega^{2}y)$ (where $\omega^2y$ encodes the output of the circuit). 
At the same time, since the gate is addition, the right operand $((1 -
S(y))\cdot \ldots)$ must evaluated to zero. The same goes for when $S(y) = 0$,
i.e., multiplication gate.

Overall, another zero-test on $H_{gates}$.

\textbf{Wirings are encoded correctly.}\\
For example, the input $6$ flows to right input of Gate0 and left input of
Gate1, we need to prove that does data flows (wiring) are encoded correctly.
For our examples, the equivalent constraints are:
$$
  \begin{cases}
    P(\omega^{-2}) = P(\omega^1) = P(\omega^3) \\
    P(\omega^{-1}) = P(\omega^0) \\
    P(\omega^{2}) = P(\omega^6) \\
    P(\omega^{3}) = P(\omega^4) \\
  \end{cases}       
$$
To do so, define a rotation polynomial $W : H \rightarrow H$ such that:
$$
  \begin{cases}
      W(\omega^{-2}, \omega^{1}, \omega^{3}) = (\omega^{3}, \omega^{-2}, \omega^{1})\\
      W(\omega^{-1}, \omega^{0}) = (\omega^{0}, \omega^{1}) \\
      \ldots \\
  \end{cases}       
$$
\begin{lemma}
    $\forall y \in H: P(y) = P(W(y)) \Rightarrow $ wiring constraints are
    satisfied.
\end{lemma}
\HL{Since W has degree of $d$ and P has degree of $d$, the verification can takes
quadratic time. The trick here is to use prod-check (another IOP check) to
reduce it to linear complexity. Not sure how to yet, another time. :P}

\textbf{Outputs are encoded correctly (is zero).}\\
Just let prover to open $P$ at the output of the final gate.

\section{STARK}
This follows the tutorial at
\href{https://aszepieniec.github.io/stark-anatomy}{here}


\subsection{Extended Euclidean Algorithm}
Refresh myself with the Extended Euclidean algorithm...

Extended Euclidean algorithm is an extension of the Euclidean algorithm, in
addition to computing the greatest common divisor of two integer $a$ and $b$,
it also gives $x$ and $y$ such that:
$$
ax + by = gcd(a, b)
$$

Recall the standard Euclidean algorithm in recursive form: $gcd(a, b) = gcd(b,
a \mod b)$, stops at $gcd(r, 0)$ and returns $r$. 

The Extended Euclidean Algorithm works the same, but keeps the quotient at
each iterations.
$$
\begin{aligned}
    r_0 = a & \ \  s_0 = 1 & t_0 = 0\\
    r_1 = b & \ \  s_1 = 0 & t_1 = 1\\
            & \ldots &  \\
           & r_i = r_{i-2} - q_{i-1} r_{i-1} \\
           & s_i = s_{i-2} - q_{i-1} s_{i-1}  \\
           & t_i = t_{i-2} - q_{i-1} t_{i-1}\\
\end{aligned}
$$

The EEA is useful as it defines the inverse of an element under $\FField$.
Give an element $x \in \FField$, the inverse of $x$ is therefore $a$:
\begin{description}
    \item $\Rightarrow gcd(x, p) = 1$
    \item $\Rightarrow ax + bp \equiv 1 \mod p$
    \item $\Rightarrow ax \equiv 1 \mod p$
\end{description}

\subsection{Lagrange Interpolation}
Refresh myself with Lagrange Interpolation.

The Lagrange Interpolation returns a polynomial of lowest degree that pass
through a set of points $D$.

As an example, consider three points $(3, 1), (4, 2), (7, -3)$. The algorithm
first construct three polynomial such that each polynomial $f_i$ go through $(x_i,
1)$ for the $i^{th}$ point in $D$ and $(x_j, 0)\ \forall j \neq i$.
This is extremely easy:

$$
\begin{cases}
    f_1(x) = \sfrac{1}{4}(x-4)(x-7) \\
    f_2(x) = \sfrac{1}{3}(x-3)(x-7) \\
    f_3(x) = \sfrac{1}{12}(x-3)(x-4) \\
\end{cases}
$$


Finally, just scale each $f_i$ so when $x = x_i \Longrightarrow y = y_i$, and let $p =
\sum_{i}f_i$
$$
p(X) = f_1(X) + 2 * f_2(X) + -3 * f_3(X)
$$

We can also prove the resulting polynomial $p(X)$ is the unique polynomial of
degree $(n-1)$ that go through those points, by contridiciton.

Assuming the opposite, let $q(X)$ be another polynomial of degree $n-1$ that
statistifes points $d \in D$. Since $q(X) \neq p(X)$, $r(X) = q(X) - p(X)$ is
not a zero polynomial and $degree(r) \leq (n-1)$. However, we know for
points $d \in D$, $r(X) = q(X) - p(X) = 0$, which means $degree(r) = n$,
therefore contridiciton.

\subsection{Generator}
\HL{Not sure yet how generator is applied in SNARK or how it is produced ---
How to produce a generator of multiplicative group of order prime?}

\subsection{Polynomial Implementation}
Just some notes on the notations here. 
\begin{description}
    \item \emph{leading coefficient} is the coefficient of the highest degree. It is
confusing as I interpreted it as the first coefficient (it is the last one).
    \item The \emph{zerofier} takes a set of domain $D$ where $\forall x \in D$, produce the
        result polynomial $f(x) = 0$.
\end{description}

\subsection{FRI}
\emph{Fast Reed-Solomon IOP of Proximity}.

FRI is a protocol between a prover and a verifier, which establishes that a
given codeword belongs to a polynomial of low degree â€“ low meaning at most $p$
times the length of the codeword. 

\subsection{Fast Fourier Transform \& Polynomials}
Consider some simple polynomial algorithms.
\begin{itemize}
    \item Multiplying two polynomial of coefficient representation. $O(n^2)$.
    \item Coefficient representation to point-value representation. $O(n^2)$ as
        you need to evaluate $n+1$ points for a $n$-degree polynomial.
    \item Lagrange. $O(n^2)$ as mentioned in previous section.
\end{itemize}

With Fast Fourier Transform, it is possible to perform above
algorithms in $O(n\log n)$.

\subsection{Point-value Representation and Polynomial Multiplication}
Consider two polynomials of degree of $n-1$:
\[
\begin{aligned}
    A(X) &= a_0 + a_1x + a_2x^2 + \ldots + a_{n-1}x^{n-1} \\
    B(X) &= b_0 + b_1x + b_2x^2 + \ldots + b_{n-1}x^{n-1} \\
\end{aligned}
\]

Each polynomial can be represented by a list of coefficients of size $n$, $a =
(a_0, a_1, \ldots, a_{n-1})$. The multiplication is represented by $a
* b$, which takes $O(n^2)$.

Another way of representing a polynomial is through the idea that a polynomial
of degree $n-1$ is uniquely defined by $n+1$ points. So
\[
    A(X) = \{(x_0, A(x_0)), (x_1, A(x_1)), \ldots, (x_{n-1}, A(x_{n-1}))\}
\]

Multiplication of two polynomial can then be defined by multiplication of those
uniquely defined points, $C(X) = A(X)B(X)$:
\[
    C(X) = \{(x_0, A(x_0)B(x_0)), (x_1, A(x_1)B(x_1)), \ldots, (x_{n-1}, A(x_{n-1})B(x_{n-1}))\}
\]
The only catch here is that $C(X)$ is a polynomial of degree $2n-2$, so we
actually need to find more points ($2n-1$) on $A$ and $B$ in order to uniquely define $C$.
However, the complexity of the multiplication drop from $O(n^2)$ to $O(n)$.

\subsubsection{Goals}
Obviously if we simply choosing arbitrary $2n$ points on the polynomial then
this will take us $O(n)$ time for each point and ends up with $O(n^2)$
complexity again. The remark here is that by choosing a specific set of points
with Fast Fourier Transform, we can find the point-value representation in
just $O(n\log n)$.

\subsubsection{Complex Root of Unity}
A number $z \in \mathbb{C}$ is an \emph{$n^{th}$ root of unity if $z^n = 1$}.
The pricipal $n$th root of unity is $\omega_n = e^{\frac{2\pi i}{n}}$.
The intution here is that $e^{\frac{2\pi i}{n}}$ is a function that rotates
as a cycle (through $i$) and has radius of $1$ (through $e^{2\pi}$), $n$ then
defines a radians of the rotation. The magic value $\omega_n^n$ then defines
each full rotation.

\begin{lemma}\label{cancel-lemma}
    For integer $n\geq 0$, $k \geq 0$, $d \geq 0$, $\omega^{dk}_{dn} = \omega^{k}_{n}$.
\end{lemma}
$$\omega^{dk}_{dn} = (e^{\frac{2\pi i}{dn}})^{dk} = (e^{\frac{2dk\pi i}{dn}}) = 
(e^{\frac{2k\pi i}{n}}) = \omega_n^{k}
$$

\begin{lemma}\label{halving-lemma}
    If $n$ is even, then squares of the $n$th complex unity root is equal to
    the $n/2$ of the $n/2$th complex unity root.
\end{lemma}
$$
\omega^2_{n} = (e^{\frac{4\pi i}{n}}) = (e^{\frac{2\pi i}{n/2}}) = \omega_{\frac{n}{2}}
$$
This extends to the $k$th power of the $n$th complex unity root:
$$
(\omega^k_{n})^2 = (\omega^{2k}_{n}) = \omega^{k}_{\frac{n}{2}}
$$
\begin{lemma}\label{summation-lemma}
    If $n \geq 1$ and $k$ is not divisible by $n$:
    $$
    \sum_{j=0}^{n-1}(\omega^{k}_n)^j = 0
    $$
Proof:
\end{lemma}
\[
    \sum_{j=0}^{n-1}(\omega^{k}_n)^j = \frac{1 - \omega^{kn}_n}{1 -\omega^{k}_n}
    = \frac{1 - (\omega^{n}_n)^k}{1 -\omega^{k}_n}
    = \frac{1 - 1^k}{1 -\omega^{k}_n}
    = 0
\]
This is true as $k$ is not divisible by $n$ hence $\omega^{k}_n \neq 1$.

\subsubsection{Discrete Fourier Transform}
Let $a = (a_0, a_1, \ldots, a_{n-1})$ be a coefficient representation of
polynomial $A$, define $\hat{a} = (\hat{a}_0, \hat{a}_1, \ldots,
\hat{a}_{n-1})$ where:
\[
    \hat{a}_k = \sum^{n-1}_{j=0}{a_j\omega^{kj}_n} 
\]

The remark is shown by considering value of polynomial $A$ at point
$\omega^k_n$.
\[
    A(\omega^k_n) = \sum^{n-1}_{j=0}{a_j\omega^{kj}_n} = \hat{a}_k.
\]

Each $A(\omega^k_n)$ still takes $O(n)$ to compute, there are still a lot of missing pieces, wait...

\subsubsection{Fast Fourier Transform}
FFT is an efficient algorithm of computing the above sequence using a
divide-and-conquer approach.

Assuming n is a power of $2$, in addition to $A(X)$, we define two other
polynomials:
\[
\begin{aligned}
    A_e(X) &= a_0 + a_2x + a_4x^2 + \ldots + a_{n-2}x^{\frac{n-2}{2}} \\
    A_o(X) &= a_1 + a_3x^1 + a_5x^{2} \ldots + a_{n-1}x^{\frac{n-2}{2}} \\
\end{aligned}
\]
We can then represent $A$ by:
\[
    A(X) = A_e(X^2) + XA_o(X^2)
\]
The problem of evaluating $A$ at $(\omega^0_n, \omega^1_n, \ldots, \omega^{n-1}_n)$
is reduced to:
\begin{enumerate}
    \item Compute $A_e$ and $A_o$ at $((\omega^0_n)^2, (\omega^1_n)^2, \ldots,
        (\omega^{n-1}_n)^2)$
    \item Combine the result
\end{enumerate}
Wait, but $A_e$ and $A_0$ only have degree $n/2$ and cannot be used to
evaluated the full sequence. But consider $d \leq \frac{n}{2}$:
\footnote{\HL{The slides specifically refers to halving
lemma~\ref{halving-lemma}, but I don't see how the lemma is necessary here to
get the conclusion.}}
\[
    (\omega^{d}_n)^2 = \omega^{2d}_{n}\omega^{n}_{n} = \omega^{2d+n}_{n} =
    (\omega^{d + \frac{n}{2}}_n)^2
\]
Therefore, calculating the first halves of the sequence give us the result in the second
halves. This also explains in the earlier section why only providing $n$ points
is enough to calculate polynomial $C$ of degree $2n-2$.

\subsubsection{Inverse of FFT}
\HL{Is it needed? TBD...}

\subsubsection{Q}
It seems like as long as $\omega_n$ statistifes that only $\omega^n_n = 1$ we
can get the same conclusion, not sure why the primitive root is used here (as
an example?). And I don't get how halving lemma is necessary to get the
final conclusion, it just uses basic exponent rules.

\end{document}
